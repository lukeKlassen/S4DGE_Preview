// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TetrahedronSlicer

#define VL_BUFFER_COUNT 2

#include "SlicerUtils.cginc"
#include "VariableLengthBufferUtils.cginc"
#include "VertexShaderUtils.cginc"

StructuredBuffer<VertexData> transformedVertices;
StructuredBuffer<Tet4D> tetsToDraw;

groupshared VLComputeBuffer triangleVerticesManager;
RWStructuredBuffer<VertexData> triangleVertices;

groupshared VLComputeBuffer slicedTrianglesManager;
RWStructuredBuffer<Triangle> slicedTriangles;
uint numTets;

struct TetIntersection {
    VertexData points[4];
    Triangle triangles[2];
    uint numPoints;
    uint numTriangles;
};

static const uint2 intersectingEdges[] = {
    // table entry 0 is empty
    uint2(0, 3), uint2(1, 3), uint2(2, 3), // entry 1
    uint2(0, 2), uint2(1, 2), uint2(3, 2), // entry 2
    uint2(0, 2), uint2(0, 3), uint2(1, 3), uint2(1, 2),  // ...
    uint2(0, 1), uint2(2, 1), uint2(3, 1),
    uint2(0, 1), uint2(0, 3), uint2(2, 3), uint2(2, 1), 
    uint2(0, 1), uint2(0, 2), uint2(2, 3), uint2(1, 3),
    uint2(0, 1), uint2(0, 2), uint2(0, 3), // last entry 8
    uint2(0, 0) // padding element at the end to avoid out of bounds access
};

// elements are (starting index, # of entries)
static const uint2 edgeTableRows[] = {
    uint2(0, 0),
    uint2(0, 3),
    uint2(3, 3),
    uint2(6, 4),
    uint2(10, 3),
    uint2(13, 4),
    uint2(17, 4),
    uint2(21, 3)
};

// return 0 if val <= 0, else return 1
int SignOp(float val) {
    return (sign(val - zSlice) == 1);
}

float4 LerpVByPZ(float4 v0, float4 v1, float4 p0, float4 p1) {
    if (p1.z == zSlice && p0.z == zSlice) {
        return v1;
    } else {
        return lerp(v0, v1, abs(p0.z - zSlice) / (abs(p1.z - zSlice) + abs(p0.z - zSlice)));
    }
}

// Slices the current tetrahedron with the plane z = 0
TetIntersection PerformSlice(uint3 globalId) {
    TetIntersection ret = (TetIntersection)0;

    // avoid updating the output buffers if the current thread is not utilized (its index is past the number of tetrahedra)
    if (globalId.x < numTets) {
        // Tetrahedron points
        VertexData pts[4] = {
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[0]],
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[1]],
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[2]],
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[3]],
        };

        // Index marching tetrahedron table based on the points
        uint intersectIndex = SignOp(pts[3].pos.z) |
            (SignOp(pts[2].pos.z) << 1) |
            (SignOp(pts[1].pos.z) << 2) |
            (SignOp(pts[0].pos.z) << 3);
        intersectIndex = min(intersectIndex, 0xF - intersectIndex); // table is symmetric

        uint rowStartIndex = edgeTableRows[intersectIndex].x;
        uint rowLength = edgeTableRows[intersectIndex].y;

        // If the intersection is non-empty

        if (rowLength >= 3) {
            // Get points in intersection
            [unroll]
            for (uint edgeIdx = 0; edgeIdx < 4; ++edgeIdx) {
                VertexData v0 = pts[intersectingEdges[edgeIdx + rowStartIndex].x];
                VertexData v1 = pts[intersectingEdges[edgeIdx + rowStartIndex].y];

                float4 p0 = v0.pos;
                float4 p1 = v1.pos;

                float4 n0 = v0.normal;
                float4 n1 = v1.normal;

                ret.points[edgeIdx].pos = LerpVByPZ(p0, p1, p0, p1);
                ret.points[edgeIdx].normal= LerpVByPZ(n0, n1, p0, p1);
            }

            // Add triangle
            ret.triangles[0].vertexIndices[0] = 0;
            ret.triangles[0].vertexIndices[1] = 1;
            ret.triangles[0].vertexIndices[2] = 2;
            ++ret.numTriangles;
            ret.numPoints = 3;

            // If the intersection is a quadrilateral, we add two triangles
            if (rowLength == 4) {
                ret.triangles[1].vertexIndices[1] = 0;
                ret.triangles[1].vertexIndices[1] = 2;
                ret.triangles[1].vertexIndices[2] = 3;
                ++ret.numTriangles;
                ret.numPoints = 4;
            }
        }
    }

    return ret;
}

[numthreads(64,1,1)]
void TetrahedronSlicer(uint3 globalId : SV_DispatchThreadID, uint3 threadId: SV_GroupThreadID)
{
    slicedTrianglesManager.Init(threadId, 0);
    triangleVerticesManager.Init(threadId, 1);
    GroupMemoryBarrierWithGroupSync(); // wait for all threads to reach this stage

    TetIntersection intersection = PerformSlice(globalId);

    uint localTriangleIndex = slicedTrianglesManager.IncreaseLocalAppendIdx(intersection.numTriangles);
    uint localPointIndex = triangleVerticesManager.IncreaseLocalAppendIdx(intersection.numPoints);
    GroupMemoryBarrierWithGroupSync();

    slicedTrianglesManager.IncreaseGlobalAppendIdx(threadId);
    triangleVerticesManager.IncreaseGlobalAppendIdx(threadId);
    GroupMemoryBarrierWithGroupSync();
    uint groupTriangleIdx = slicedTrianglesManager.GetGroupAppendIdx();
    uint groupPointIdx = triangleVerticesManager.GetGroupAppendIdx();

    // Set the points for the current tetrahedron intersection
    for (uint pointIdx = 0; pointIdx < intersection.numPoints; ++pointIdx) {
        // since the z-coordinate is always 0 (from vertex shader)
        // we piggyback the w-coordinate into z fto leverage hardware depth-testing
        triangleVertices[groupPointIdx + localPointIndex + pointIdx].pos.xyz = intersection.points[pointIdx].pos.xyw;
        triangleVertices[groupPointIdx + localPointIndex + pointIdx].pos.w = 1;

        // keep the normal as a 4D vector
        triangleVertices[groupPointIdx + localPointIndex + pointIdx].normal = intersection.points[pointIdx].normal;
    }

    // Set the triangles for the current tetrahedron intersection
    for (uint triangleIdx = 0; triangleIdx < intersection.numTriangles; ++triangleIdx) {
        // Current triangle vertex indices are just offsets, make them refer to the actual index in triangleVertices
        Triangle curTriangle;
        curTriangle.vertexIndices[0] = groupPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[0];
        curTriangle.vertexIndices[1] = groupPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[1];
        curTriangle.vertexIndices[2] = groupPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[2];

        slicedTriangles[groupTriangleIdx + localTriangleIndex + triangleIdx] = curTriangle;
    }
}
