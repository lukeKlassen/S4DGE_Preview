// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TetrahedronSlicer

#define VL_BUFFER_COUNT 2

#include "SlicerUtils.cginc"
#include "VariableLengthBufferUtils.cginc"
#include "VertexShaderUtils.cginc"

StructuredBuffer<VertexData> transformedVertices;
StructuredBuffer<Tet4D> tetsToDraw;

groupshared VLComputeBuffer triangleVerticesManager = (VLComputeBuffer)0;
RWStructuredBuffer<float4> triangleVertices;

groupshared VLComputeBuffer slicedTrianglesManager = (VLComputeBuffer)0;
RWStructuredBuffer<Triangle> slicedTriangles;
uint numTets;

struct TetIntersection {
    float4 points[4];
    Triangle triangles[2];
    uint numPoints;
    uint numTriangles;
};

static const uint2 intersectingEdges[] = {
    // table entry 0 is empty
    uint2(0, 3), uint2(1, 3), uint2(2, 3), // entry 1
    uint2(0, 2), uint2(1, 2), uint2(3, 2), // entry 2
    uint2(0, 2), uint2(0, 3), uint2(1, 3), uint2(1, 2),  // ...
    uint2(0, 1), uint2(2, 1), uint2(3, 1),
    uint2(0, 1), uint2(0, 3), uint2(2, 3), uint2(2, 1), 
    uint2(0, 1), uint2(0, 2), uint2(2, 3), uint2(1, 3),
    uint2(0, 1), uint2(0, 2), uint2(0, 3), // last entry 8
    uint2(0, 0) // padding element at the end to avoid out of bounds access
};

// elements are (starting index, # of entries)
static const uint2 edgeTableRows[] = {
    uint2(0, 0),
    uint2(0, 3),
    uint2(3, 3),
    uint2(6, 4),
    uint2(10, 3),
    uint2(13, 4),
    uint2(17, 4),
    uint2(21, 3)
};

// return 0 if val <= 0, else return 1
int SignOp(int val) {
    return sign(val) == 1;
}

// Slices the current tetrahedron with the plane z = 0
TetIntersection PerformSlice(uint3 globalId) {
    TetIntersection ret = (TetIntersection)0;

    // avoid updating the output buffers if the current thread is not utilized (its index is past the number of tetrahedra)
    if (globalId.x < numTets) {
        // Tetrahedron points
        float4 pts[4] = {
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[0]].pos,
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[1]].pos,
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[2]].pos,
            transformedVertices[tetsToDraw[globalId.x].vertexIndices[3]].pos,
        };

        // Index marching tetrahedron table based on the points
        uint intersectIndex = SignOp(pts[3].z) |
            (SignOp(pts[2].z) << 1) |
            (SignOp(pts[1].z) << 2) |
            (SignOp(pts[0].z) << 3);
        intersectIndex = min(intersectIndex, 0xF - intersectIndex); // table is symmetric

        uint rowStartIndex = edgeTableRows[intersectIndex].x;
        uint rowLength = edgeTableRows[intersectIndex].y;

        // If the intersection is non-empty

        if (rowLength >= 3) {
            // Get points in intersection
            [unroll]
            for (uint edgeIdx = 0; edgeIdx < 4; ++edgeIdx) {
                float4 p0 = pts[intersectingEdges[edgeIdx + rowStartIndex].x];
                float4 p1 = pts[intersectingEdges[edgeIdx + rowStartIndex].y];

                ret.points[edgeIdx] = lerp(p0, p1, abs(p0.z) / (abs(p1.z) + abs(p0.z)));
            }

            // Add triangle
            ret.triangles[0].vertexIndices[0] = 0;
            ret.triangles[0].vertexIndices[1] = 1;
            ret.triangles[0].vertexIndices[2] = 2;
            ++ret.numTriangles;
            ret.numPoints = 3;

            // If the intersection is a quadrilateral, we add two triangles
            if (rowLength == 4) {
                ret.triangles[1].vertexIndices[1] = 0;
                ret.triangles[1].vertexIndices[1] = 2;
                ret.triangles[1].vertexIndices[2] = 3;
                ++ret.numTriangles;
                ret.numPoints = 4;
            }
        }
    }

    return ret;
}

[numthreads(64,1,1)]
void TetrahedronSlicer(uint3 globalId : SV_DispatchThreadID, uint3 threadId: SV_GroupThreadID)
{
    slicedTrianglesManager.Init(threadId, 0);
    triangleVerticesManager.Init(threadId, 1);
    GroupMemoryBarrierWithGroupSync(); // wait for all threads to reach this stage

    TetIntersection intersection = PerformSlice(globalId);

    uint localTriangleIndex = slicedTrianglesManager.IncreaseLocalAppendIdx(intersection.numTriangles);
    uint localPointIndex = triangleVerticesManager.IncreaseLocalAppendIdx(intersection.numPoints);
    GroupMemoryBarrierWithGroupSync();

    slicedTrianglesManager.IncreaseGlobalAppendIdx(threadId);
    triangleVerticesManager.IncreaseGlobalAppendIdx(threadId);
    GroupMemoryBarrierWithGroupSync();
    uint groupTriangleIdx = slicedTrianglesManager.GetGroupAppendIdx();
    uint groupPointIdx = triangleVerticesManager.GetGroupAppendIdx();

    // Set the points for the current tetrahedron intersection
    for (uint pointIdx = 0; pointIdx < intersection.numPoints; ++pointIdx) {
        triangleVertices[groupPointIdx + localPointIndex + pointIdx] = intersection.points[pointIdx];
    }

    // Set the triangles for the current tetrahedron intersection
    for (uint triangleIdx = 0; triangleIdx < intersection.numTriangles; ++triangleIdx) {
        // Current triangle vertex indices are just offsets, make them refer to the actual index in triangleVertices
        Triangle curTriangle;
        curTriangle.vertexIndices[0] = groupPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[0];
        curTriangle.vertexIndices[1] = groupPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[1];
        curTriangle.vertexIndices[2] = groupPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[2];

        slicedTriangles[groupTriangleIdx + localTriangleIndex + triangleIdx] = curTriangle;
    }
}
