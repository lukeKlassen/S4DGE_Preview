// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TetrahedronSlicer

#define VL_BUFFER_COUNT 2

#include "SlicerUtils.cginc"
#include "VariableLengthBufferUtils.cginc"

StructuredBuffer<float4> transformedVertices;
StructuredBuffer<Tet4D> tetsToDraw;
RWStructuredBuffer<float4> triangleVertices;
RWStructuredBuffer<Triangle> slicedTriangles;

struct TetIntersection {
    float4 points[4];
    Triangle triangles[2];
    uint numPoints;
    uint numTriangles;
};

uint2 intersectingEdges[] = {
    // table entry 0 is empty
    uint2(0, 3), uint2(1, 3), uint2(2, 3), // entry 1
    uint2(0, 2), uint2(1, 2), uint2(2, 2), // entry 2
    uint2(0, 2), uint2(1, 2), uint2(0, 3), uint2(1, 3), // ...
    uint2(0, 1), uint2(2, 1), uint2(3, 1),
    uint2(0, 1), uint2(0, 3), uint2(2, 1), uint2(2, 3),
    uint2(0, 1), uint2(0, 2), uint2(1, 3), uint2(2, 3),
    uint2(0, 1), uint2(0, 2), uint2(0, 3)
};

// elements are (starting index, # of entries)
uint2 edgeTableRows[] = {
    uint2(0, 0),
    uint2(0, 3),
    uint2(3, 3),
    uint2(6, 4),
    uint2(10, 3),
    uint2(13, 4),
    uint2(17, 4),
    uint2(21, 3)
};

// return 0 if val <= 0, else return 1
int SignOp(int val) {
    return sign(val) == 1;
}

// Slices the current tetrahedron with the plane z = 0
TetIntersection PerformSlice(uint3 globalId) {
    // Tetrahedron points
    float4 pts[4] = {
        transformedVertices[tetsToDraw[globalId.x].vertexIndices[0]],
        transformedVertices[tetsToDraw[globalId.x].vertexIndices[1]],
        transformedVertices[tetsToDraw[globalId.x].vertexIndices[2]],
        transformedVertices[tetsToDraw[globalId.x].vertexIndices[3]],
    };

    // Index marching tetrahedron table based on the points
    uint intersectIndex = SignOp(pts[3].z) |
        (SignOp(pts[2].z) << 1) |
        (SignOp(pts[1].z) << 2) |
        (SignOp(pts[0].z) << 3);
    intersectIndex = min(intersectIndex, 0xF - intersectIndex); // table is symmetric

    uint rowStartIndex = edgeTableRows[intersectIndex].x;
    uint rowLength = edgeTableRows[intersectIndex].y;

    // If the intersection is non-empty
    Triangle intersectedTriangles[2];
    uint numTrianglesInIntersection = 0;
    uint numIntersectingPoints = 0;
    float4 planeIntersections[4];
    if (rowLength >= 3) {
        // Get points in intersection
        for (uint edgeIdx = rowStartIndex; edgeIdx < rowStartIndex + 3; ++edgeIdx) {
            float4 p0 = transformedVertices[intersectingEdges[edgeIdx].x];
            float4 p1 = transformedVertices[intersectingEdges[edgeIdx].y];

            planeIntersections[edgeIdx - rowStartIndex] = lerp(p0, p1, (-p0 / (p1 - p0)).zzzz);
        }

        // Add triangle
        intersectedTriangles[0].vertexIndices[0] = 0;
        intersectedTriangles[0].vertexIndices[1] = 1;
        intersectedTriangles[0].vertexIndices[2] = 2;
        ++numTrianglesInIntersection;
        numIntersectingPoints = 3;

        // If the intersection is a quadrilateral, we add two triangles
        if (rowLength == 4) {
            intersectedTriangles[1].vertexIndices[0] = 2;
            intersectedTriangles[1].vertexIndices[1] = 3;
            intersectedTriangles[1].vertexIndices[2] = 0;
            ++numTrianglesInIntersection;
            numIntersectingPoints = 4;
        }
    }

    TetIntersection ret;
    ret.points = planeIntersections;
    ret.numPoints = numIntersectingPoints;
    ret.triangles = intersectedTriangles;
    ret.numTriangles = numTrianglesInIntersection;

    return ret;
}

[numthreads(64,1,1)]
void TetrahedronSlicer(uint3 globalId : SV_DispatchThreadID, uint3 threadId: SV_GroupThreadID)
{
    InitLocalAppendIdx(threadId, 0);
    InitLocalAppendIdx(threadId, 1);
    GroupMemoryBarrierWithGroupSync(); // wait for all threads to reach this stage

    TetIntersection intersection = PerformSlice(globalId);

    uint localTriangleIndex = IncreaseLocalAppendIdx(intersection.numTriangles, 0);
    uint localPointIndex = IncreaseLocalAppendIdx(intersection.numPoints, 1);
    GroupMemoryBarrierWithGroupSync();

    uint globalTriangleIdx = IncreaseGlobalAppendIdx(threadId, 0);
    uint globalPointIdx = IncreaseGlobalAppendIdx(threadId, 1);
    GroupMemoryBarrierWithGroupSync();

    // Set the points for the current tetrahedron intersection
    for (uint pointIdx = 0; pointIdx < intersection.numPoints; ++pointIdx) {
        triangleVertices[globalPointIdx + localPointIndex + pointIdx] = intersection.points[pointIdx];
    }

    // Set the triangles for the current tetrahedron intersection
    for (uint triangleIdx = 0; triangleIdx < intersection.numTriangles; ++triangleIdx) {
        // Current triangle vertex indices are just offsets, make them refer to the actual index in triangleVertices
        Triangle curTriangle;
        curTriangle.vertexIndices[0] = globalPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[0];
        curTriangle.vertexIndices[1] = globalPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[1];
        curTriangle.vertexIndices[2] = globalPointIdx + localPointIndex + intersection.triangles[triangleIdx].vertexIndices[2];

        slicedTriangles[globalTriangleIdx + localTriangleIndex + triangleIdx] = curTriangle;
    }
}
